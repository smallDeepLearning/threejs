<!DOCTYPE html>
<html lang="en">
	<head>
		<title>几何-形状</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
		</style>
	</head>
	<body>

		<div id="info">Simple procedurally-generated shapes</div>
		<script type="module">
			import * as THREE from '../build/three.module.js';
			import Stats from './jsm/libs/stats.module.js';

			var container, stats;
			var camera, scene, renderer;
			var group;

			var targetRotation = 0; // 默认旋转度
			var targetRotationOnMouseDown = 0; // 默认旋转起始点

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;

			init();
			animate();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xf0f0f0);

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.set(0, 0, 700);
				// 添加透视投影相机
				scene.add(camera);

				var light = new THREE.PointLight(0xffffff, 0.8);
				// 添加点光源
				camera.add(light);

				group = new THREE.Group();
				group.position.y = -75;
				// 添加组
				scene.add(group);

				var loader = new THREE.TextureLoader();
				// 添加UV坐标图
				var texture = loader.load("textures/UV_Grid_Sm.jpg");

				// it's necessary to apply these settings in order to correctly display the texture on a shape geometry
				// 这是有必要的应用这些设置，以正确显示形状几何形状的纹理
				// wrapS: 定义了纹理贴图在水平方向上将如何包裹，在UV映射中对应于U
				// wrapT: 定义了纹理贴图在垂直方向上将如何包裹，在UV映射中对应于V
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				// 纹理将在表面上，分别在U、V方向上重复多少次
				texture.repeat.set(0.008, 0.008);
				/**
				 * 添加形状
				 * @shape [Shape] -- 绘制形状
				 * @extrudeSettings [Object] -- 挤出对象
				 * @color [Number] -- 颜色数值
				 * @xyz [Number] -- Mesh的坐标位置
				 * @rxryrz [Number] -- Mesh的旋转角度
				 * @s [Number] -- 缩放尺寸
				 */
				function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
					// note: default UVs generated by THREE.ShapeBufferGeometry are simply the x- and y-coordinates of the vertices
					// 笔记: UVs默认是由THREE.ShapeBufferGeometry的顶点坐标(x, y)来构成的
					// flat shape
					var geometry = new THREE.ShapeBufferGeometry(shape);
					var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({side: THREE.DoubleSide, map: texture})); // UV贴图
					mesh.position.set(x, y, z - 175);
					mesh.rotation.set(rx, ry, rz);
					mesh.scale.set(s, s, s);
					group.add(mesh);

					// flat shape
					var geometry = new THREE.ShapeBufferGeometry(shape);
					var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({color: color, side: THREE.DoubleSide})); // 颜色
					mesh.position.set(x, y, z - 125);
					mesh.rotation.set(rx, ry, rz);
					mesh.scale.set(s, s, s);
					group.add(mesh);

					// 挤压缓冲几何体
					/**
					 * 构造器 == 该对象将一个二维形状挤出为一个三维几何体
					 * ExtrudeBufferGeometry(shapes: Array, options: Object)
					 * shapes -- 形状或者一个包含形状的数组
					 * options -- 一个包含有下列参数的对象
					 */
					// 重点: 当使用这个几何体创建Mesh的时候，如果你希望分别对它的表面和它挤出的侧面使用单独的材质，你可以使用一个材质数组。
					// 第一个材质用于其表面、第二个材质则将用于其挤出的侧面
					var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
					var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({color: color}));
					mesh.position.set(x, y, z -75);
					mesh.rotation.set(rx, ry, rz);
					mesh.scale.set(s, s, s);
					group.add(mesh);

					addLineShape(shape, color, x, y, z, rx, ry, rz, s);
				}
				/**
				 * 添加线形
				 */
				function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
					// lines
					shape.autoClose = true;

					var points = shape.getPoints();
					var spacedPoints = shape.getSpacedPoints(50);

					var geometryPoints = new THREE.BufferGeometry().setFromPoints(points);
					var geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(spacedPoints);

					// solid line -- 实线
					var line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({color: color}));
					line.position.set(x, y, z-25);
					line.rotation.set(rx, ry, rz);
					line.scale.set(s, s, s);
					group.add(line);

					// line from equidistance sampled points -- 等距采样点的直线
					var line = new THREE.Line(geometrySpacedPoints, new THREE.LineBasicMaterial({color: color}));
					line.position.set(x, y, z+75);
					line.rotation.set(rx, ry, rz);
					line.scale.set(s, s, s);
					group.add(line);

					// vertices from real points -- 实点的顶点
					var particles = new THREE.Points(geometryPoints, new THREE.PointsMaterial({color: color, size: 4}));
					particles.position.set(x, y, z+25);
					particles.rotation.set(rx, ry, rz);
					particles.scale.set(s, s, s);
					group.add(particles);

					// equidistance sampled points -- 等距离采样点
					var particles = new THREE.Points(geometrySpacedPoints, new THREE.PointsMaterial({color: color, size: 4}));
					particles.position.set(x, y, z+125);
					particles.rotation.set(rx, ry, rz);
					particles.scale.set(s, s, s);
					group.add(particles);
				}

				var californiaPts = [];
				/**
				 * Vector2(x: Float, y: Float) -- 二维向量
				 * x - 向量的x值
				 * y - 向量的y值
				 */
				californiaPts.push(new THREE.Vector2(610, 320));
				californiaPts.push(new THREE.Vector2(450, 300));
				californiaPts.push(new THREE.Vector2(392, 392));
				californiaPts.push(new THREE.Vector2(266, 438));
				californiaPts.push(new THREE.Vector2(190, 570));
				californiaPts.push(new THREE.Vector2(190, 600));
				californiaPts.push(new THREE.Vector2(160, 620));
				californiaPts.push(new THREE.Vector2(160, 650));
				californiaPts.push(new THREE.Vector2(180, 640));
				californiaPts.push(new THREE.Vector2(165, 680));
				californiaPts.push(new THREE.Vector2(150, 670));
				californiaPts.push(new THREE.Vector2(90, 737));
				californiaPts.push(new THREE.Vector2(80, 795));
				californiaPts.push(new THREE.Vector2(50, 835));
				californiaPts.push(new THREE.Vector2(64, 870));
				californiaPts.push(new THREE.Vector2(60, 945));
				californiaPts.push(new THREE.Vector2(300, 945));
				californiaPts.push(new THREE.Vector2(300, 743));
				californiaPts.push(new THREE.Vector2(600, 473));
				californiaPts.push(new THREE.Vector2(626, 425));
				californiaPts.push(new THREE.Vector2(600, 370));
				californiaPts.push(new THREE.Vector2(610, 320));

				for (var i = 0; i < californiaPts.length; i ++) californiaPts[i].multiplyScalar(0.25); // 将该向量与所传入的标量s进行相乘

				/**
				 * Shape(points: Array)
				 * points [Array] -- 一个Vector2数组
				 */
				// 从点来创建一个Shape -- 加洲
				// 第一个点定义了偏移量，接下来的点被作为LineCurves加入到curves中
				var californiaShape = new THREE.Shape(californiaPts); // THREE.Shape

				// Triangle -- 三角形
				var triangleShape = new THREE.Shape(); // 使用路径以及可选的孔洞来定义一个二维形状平面
				triangleShape.moveTo(80, 20); // moveTo -- 将绘图点移动到(80, 20)
				triangleShape.lineTo(40, 80); // lineTo -- 从(80, 20)位置起绘制一条直线到(40, 80)
				triangleShape.lineTo(120, 80);
				triangleShape.lineTo(80, 20); // close path -- 合并路径

				// Heart -- 心形
				var x = 0, y = 0;
				// 辅助参考 -- https://www.cnblogs.com/amy2011/p/6357559.html
				var heartShape = new THREE.Shape(); // From http://blog.burlock.org/html5/130-paths
				heartShape.moveTo(x + 25, y + 25);
				// .currentPoint [Vector2] -- 二维向量
				/**
				 * 从.currentPoint创建一条贝塞尔曲线，以(cp1X, cp1Y)和(cp2X, cp2Y)作为控制点，并将.currentPoint更新到x,y
				 * bezierCurveTo(cp1X: Float, cp1Y: Float, cp2X: Float, cp2Y: Float, x: Float, y: Float)
				 */
				heartShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y);
				heartShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35);
				heartShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
				heartShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
				heartShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y);
				heartShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

				// Square -- 方形
				var sqLength = 80;
				var squareShape = new THREE.Shape();
				squareShape.moveTo(0, 0);
				squareShape.lineTo(0, sqLength); // (0, 80)
				squareShape.lineTo(sqLength, sqLength); // (80, 80)
				squareShape.lineTo(sqLength, 0); // (80, 0)
				squareShape.lineTo(0, 0);

				// Rectangle -- 矩形
				var rectLength = 120, rectWidth = 40;
				var rectShape = new THREE.Shape();
				rectShape.moveTo(0, 0);
				rectShape.lineTo(0, rectWidth); // (0, 40)
				rectShape.lineTo(rectLength, rectWidth); // (120, 40)
				rectShape.lineTo(rectLength, 0); // (120, 0)
				rectShape.lineTo(0, 0);

				// Rounded rectangle -- 圆角矩形
				var roundedRectShape = new THREE.Shape();
				(function roundedRect(ctx, x, y, width, height, radius) {
					ctx.moveTo(x, y + radius);
					ctx.lineTo(x, y + height - radius);
					/**
					* 从.currentPoint创建一条二次曲线，以(cpX,cpY)作为控制点，并将.currentPoint更新到x,y
					* quadraticCurveTo(cpX: Float, cpY: Float, x: Float, y: Float)
					*/
					ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
					ctx.lineTo(x + width - radius, y + height);
					ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
					ctx.lineTo(x + width, y + radius);
					ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
					ctx.lineTo(x + radius, y);
					ctx.quadraticCurveTo(x, y, x, y + radius);
				})(roundedRectShape, 0, 0, 50, 50, 20);

				// Track
				var trackShape = new THREE.Shape();
				trackShape.moveTo(40, 40);
				trackShape.lineTo(40, 160);
				trackShape.absarc(60, 160, 20, Math.PI, 0, true);
				trackShape.lineTo(80, 40);
				trackShape.absarc(60, 40, 20, 2 * Math.PI, Math.PI, true);

				// Circle -- 圆圈
				var circleRadius = 40;
				var circleShape = new THREE.Shape();
				circleShape.moveTo(0, circleRadius);
				circleShape.quadraticCurveTo(circleRadius, circleRadius, circleRadius, 0);
				circleShape.quadraticCurveTo(circleRadius, - circleRadius, 0, - circleRadius);
				circleShape.quadraticCurveTo(-circleRadius, - circleRadius, - circleRadius, 0);
				circleShape.quadraticCurveTo(-circleRadius, circleRadius, 0, circleRadius);

				// Fish -- 鱼形
				var x = y = 0;
				var fishShape = new THREE.Shape();
				fishShape.moveTo(x, y);
				fishShape.quadraticCurveTo(x + 50, y - 80, x + 90, y - 10);
				fishShape.quadraticCurveTo(x + 100, y - 10, x + 115, y - 40);
				fishShape.quadraticCurveTo(x + 115, y, x + 115, y + 40);
				fishShape.quadraticCurveTo(x + 100, y + 10, x + 90, y + 10);
				fishShape.quadraticCurveTo(x + 50, y + 80, x, y);

				// Arc circle -- 圆弧
 				var arcShape = new THREE.Shape();
				arcShape.moveTo(50, 10 );
				/**
				 * absarc(x: Float, y: Float, radius: Float, startAngle: Float, endAngle: Float, clockwise: Boolean)
				 * x, y -- 弧线的绝对中心
				 * radius -- 弧线的半径
				 * startAngle -- 起始角，以弧度来表示
				 * endAngle -- 终止角，以弧度来表示
				 * clockwise -- 以顺时针方向来创建弧线
				 */
				arcShape.absarc(10, 10, 40, 0, Math.PI * 2, false);
				var holePath = new THREE.Path(); // 路径
				holePath.moveTo(20, 10 );
				holePath.absarc(10, 10, 10, 0, Math.PI * 2, true);
				// holes作为Shape的属性，一个数组，定义了形状上的孔洞
				arcShape.holes.push(holePath);

				// Smiley -- 笑脸
				var smileyShape = new THREE.Shape();
				smileyShape.moveTo(80, 40);
				smileyShape.absarc(40, 40, 40, 0, Math.PI * 2, false);
				// Eye1
				var smileyEye1Path = new THREE.Path();
				smileyEye1Path.moveTo(35, 20);
				// Curve => CurvePath => Path => Shape
				/**
				 * absellipse(x: Float, y: Float, xRadius: Float, yRadius: Float, startAngle: Float, endAngle: Float, clockwise: Boolean, rotation: Float)
				 * x, y -- 椭圆的绝对中心
				 * xRadius -- 椭圆的x轴方向的半径
				 * yRadius -- 椭圆的y轴方向的半径
				 * startAngle -- 起始角，以弧度来表示
				 * endAngle -- 终止角，以弧度表示
				 * clockwise -- 以顺时针方向来创建(扫过)椭圆，默认值为false
				 * rotation -- 椭圆从X轴正方向逆时针的旋转角度(可选)，以弧度表示，默认值为0
				 */
				smileyEye1Path.absellipse(25, 20, 10, 10, 0, Math.PI * 2, true);
				smileyShape.holes.push(smileyEye1Path);
				// Eye2
				var smileyEye2Path = new THREE.Path();
				smileyEye2Path.moveTo(65, 20);
				smileyEye2Path.absarc(55, 20, 10, 0, Math.PI * 2, true);
				smileyShape.holes.push(smileyEye2Path);
				// Mouth
				var smileyMouthPath = new THREE.Path();
				smileyMouthPath.moveTo(20, 40);
				smileyMouthPath.quadraticCurveTo(40, 60, 60, 40);
				smileyMouthPath.bezierCurveTo(70, 45, 70, 50, 60, 60);
				smileyMouthPath.quadraticCurveTo(40, 80, 20, 60);
				smileyMouthPath.quadraticCurveTo(5, 50, 20, 40);
				smileyShape.holes.push(smileyMouthPath);

				// Spline shape -- 曲线形状
				var splinepts = [];
				splinepts.push(new THREE.Vector2(70, 20));
				splinepts.push(new THREE.Vector2(80, 90));
				splinepts.push(new THREE.Vector2(-30, 70));
				splinepts.push(new THREE.Vector2(0, 0));

				var splineShape = new THREE.Shape();
				splineShape.moveTo(0, 0);
				/**
				 * splineThru(points: Array)
				 * points -Vector2数组
				 * 连接一条新的SplineCurve到路径上
				 */
				splineShape.splineThru(splinepts);

				// 突出变形
				var extrudeSettings = {
					depth: 8, // [float] -- 挤出的形状的深度，默认值为 100
					steps: 2, // [int] -- 用于沿着挤出样条的深度细分的点的数量，默认值为 1
					bevelEnabled: true, // [boolean] -- 对挤出的形状应用是否斜角，默认值为 true
					bevelSegments: 2, // [int] -- 斜角的分段层数，默认值为 3
					bevelSize: 1, // [float] -- 斜角与原始形状轮廓之间的延伸距离，默认值为 bevelThickness-2
					bevelThickness: 1 // [float] -- 设置原始形状上斜角的厚度，默认值为 6
				};

				// addShape(californiaShape, extrudeSettings, 0xf08000, - 300, - 100, 0, 0, 0, 0, 1);
				// addShape(triangleShape, extrudeSettings, 0x8080f0, - 180, 0, 0, 0, 0, 0, 1);
				// addShape(roundedRectShape, extrudeSettings, 0x008000, - 150, 150, 0, 0, 0, 0, 1);
				// addShape(trackShape, extrudeSettings, 0x008080, 200, - 100, 0, 0, 0, 0, 1);
				addShape(squareShape, extrudeSettings, 0x0040f0, 150, 100, 0, 0, 0, 0, 1);
				// addShape(heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1);
				// addShape(circleShape, extrudeSettings, 0x00f000, 120, 250, 0, 0, 0, 0, 1);
				// addShape(fishShape, extrudeSettings, 0x404040, - 60, 200, 0, 0, 0, 0, 1);
				// addShape(smileyShape, extrudeSettings, 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1);
				// addShape(arcShape, extrudeSettings, 0x804000, 150, 0, 0, 0, 0, 0, 1);
				// addShape(splineShape, extrudeSettings, 0x808080, - 50, - 100, 0, 0, 0, 0, 1);

				// addLineShape(arcShape.holes[0], 0x804000, 150, 0, 0, 0, 0, 0, 1); // 圆圈补孔

				// for (var i = 0; i < smileyShape.holes.length; i+= 1) {
				// 	addLineShape(smileyShape.holes[i], 0xf000f0, - 200, 250, 0, 0, 0, Math.PI, 1); // 笑脸补表情
				// }

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				stats = new Stats();
				container.appendChild(stats.dom);

				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('touchstart', onDocumentTouchStart, false);
				document.addEventListener('touchmove', onDocumentTouchMove, false);

				window.addEventListener('resize', onWindowResize, false);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onDocumentMouseDown(event) {
				event.preventDefault();
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener('mouseup', onDocumentMouseUp, false);
				document.addEventListener('mouseout', onDocumentMouseOut, false);

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;
			}

			function onDocumentMouseMove(event) {
				mouseX = event.clientX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
			}

			function onDocumentMouseUp() {
				document.removeEventListener('mousemove', onDocumentMouseMove, false);
				document.removeEventListener('mouseup', onDocumentMouseUp, false);
				document.removeEventListener('mouseout', onDocumentMouseOut, false);
			}

			function onDocumentMouseOut() {
				document.removeEventListener('mousemove', onDocumentMouseMove, false);
				document.removeEventListener('mouseup', onDocumentMouseUp, false);
				document.removeEventListener('mouseout', onDocumentMouseOut, false);
			}

			function onDocumentTouchStart(event) {
				if (event.touches.length == 1) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;
				}
			}

			function onDocumentTouchMove(event) {
				if (event.touches.length == 1) {
					event.preventDefault();
					mouseX = event.touches[0].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;
				}
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
				stats.update();
			}

			function render() {
				group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
